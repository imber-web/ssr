## 前言：

定义：**SSR**: Server-side rendering 服务端渲染，**CSR**: Client-side rendering 客户端渲染，**SSG**: Static-side generation 静态站点生成;

解释：服务端渲染意味着页面在服务端已经渲染好，然后返回给浏览器渲染；

区分：典型的用Vue-cli创建的SPA(单页面应用)项目，是属于CSR，用Nuxt.js或者Next.js创建的MPA(多页面应用)项目则是SSR。可以在浏览器右键查看页面源代码，页面里很多标签的则是SSR，页面里基本没标签的，是通过JS来渲染的CSR，或者控制台在network看响应回来是一个页面的则说明是SSR；

用途：常用在C端网站，商城，官网等项目，对比于后台管理系统，有比较多的优化场景。

## SSR为什么利于SEO?

浏览器爬虫会爬取页面信息（理解为请求并分析HTML），作为浏览器搜索排名指标之一（当然，砸钱可能最有用）；

SPA单页面，只有一个html，这个html里面的标签更是少之又少，浏览器爬虫爬取不到有用的信息，自然不利于SEO，而SSR返回一个渲染完成的静态HTML，里面有足够的信息，所以利于SEO。

## SSR为什么首屏渲染更快(减少白屏时间)？

**DOMContentLoaded**（HTML加载完毕，不用等图片，外部样式表等加载就触发），可以用来衡量页面加载速度，onload则要等待页面全部内容加载完毕后才触发；可以在浏览器控制台network最下面看到触发时间；

可以用浏览器`Performance API`去计算一些性能指标，也可以去跑lighthouse，lighthouse除了会给你统计数据，还会总结告诉你怎么优化，这里举例两个有用的指标：

**FP 白屏**：First Paint Time，从页面开始加载到浏览器中检测到渲染（任何渲染）时被触发（例如背景改变，样式应用等 performace计算公式：responseStart - navigationStart；

**FCP 首屏**：first contentful paint，从页面开始加载到页面内容的任何部分呈现在屏幕上的时间，关注的焦点是内容，这个度量可以知道用户什么时候收到有用的信息（文本，图像等）；

与首屏渲染速度相关的有很有因素，这里举例几个重要的因素（可以从输入URL到页面渲染这个流程中来发现优化的地方）：资源的体积，js阻塞渲染等，知道了这些因素后，再来看看SSR与这些因素有何相关；

传统的SPA，客户端会先请求到一个html，再通过里面的script标签去请求别的js，可以想象成是串型的（http2有所优化，有服务端推送功能server push，会并行的把js等文件传给客户端），需要异步获取js，而js是阻塞渲染的；而SSR的js会在返回页面的时候放在html里面（这里面还有同构的概念，比如页面中事件是用hydateRoot在客户端处理，再进行一次渲染，脱水和注水也是同构的一环；简单理解为共同构建，服务端做html和css处理，客户度做事件挂载），节省了异步fetch js的时间。

## SSR基本原理？

